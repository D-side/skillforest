# Лес навыков

> Русская версия поддерживается [в ветке `ru`](https://github.com/D-side/skillforest/tree/ru). Основной является версия на английском языке.
>
> Предлагать изменения на русском тоже можно, в порядке [обсуждения](https://github.com/D-side/skillforest/issues/new), в первую очередь изменения будут вноситься в английскую версию, и в русскую только переводиться (что при наличии обсуждения на русском будет максимально просто).
>
> Это всего лишь набор определений, использоваться они, скорее всего, поначалу будут именно для русскоязычных произведений. Английский язык выбран, как [*lingua franca*](https://ru.wikipedia.org/wiki/%D0%9B%D0%B8%D0%BD%D0%B3%D0%B2%D0%B0_%D1%84%D1%80%D0%B0%D0%BD%D0%BA%D0%B0) индустрии, чтобы проект можно было продемонстрировать и коллегам, не говорящим на русском языке: в англоязычной среде знаний и источников всё-таки намного больше и развиться подобные вещи в ней могут гораздо сильнее.

Лес навыков это инструмент для отслеживания навыков и способов их развивать. "Дерево навыков", хорошо известное понятие в ролевых играх (RPG), это набор навыков, в котором некоторые навыки зависят от некоторых других. Лес навыков то среда, где **отдельные деревья** навыков могут расти и взаимодействовать между собой. Отсюда и название **"лес навыков"**.

Сейчас проект **на стадии проектирования**, реализация даже не началась. Поскольку в проекте наверняка будет иметь место взаимодействие между серверами по принципу "федерации", определить это взаимодействие максимально формально важно на ранних стадиях проекта, чтобы разные реализации этой спецификации могли развиваться параллельно и быстрее показывать слабые места.

## Зачем это надо

Известно множество попыток "игрофицировать" процесс получения технических навыков. Большая их часть это более-менее прямые применения игровых концепций к реальным навыкам: достижения, уровни, и т. д. Но применение тех же концепций к реальным навыкам требует **серьёзных упрощений**. Настолько серьёзных, что в результате получается масса слабых мест.

Разработка этой концепции началась в ответ на предложение на [meta.ru.StackOverflow][3] собирать "СПИски Навыков И Знаний", грубо разбитые на уровни "начальный", "средний" и "продвинутый", где к каждому пункту приложены материалы для изучения.

Сейчас в сообществе принято составлять "списки литературы", состоящие из общих ответов со списками книг по теме вопроса. Но это плохо отвечает на вопрос "что мне нужно знать, чтобы получить работу". Подобные вопросы всё равно плохо ложатся на формат StackOverflow, но время от времени их задают и хоть где-то на них ответить стоит. Разумеется, **единственно верного ответа нет**, ведь на определённых этапах нужно будет делать выбор.

## Идея

Просто разбитый на категории список навыков свою задачу выполняет плохо:

* В списке всегда есть порядок, хотя бы перечисления, даже если никакого значения этому порядку при написании не придавалось
* Уровни "начальный", "средний" и "продвинутый" субъективны и неоднозначны
* Навыки не выстраиваются в линейную структуру, а между её элементами встречаются непростые зависимости

Мы решаем все эти недостатки использованием [**графа**][1] вместо спсика. Навыки представлены в виде **узлов** графа, соединённых рёбрами-**требованиями**. Процесс отслеживания навыков строится вокруг **установки** и **снятия** отметок с навыков. **Отметка** на навыке это заявление о владении этим навыком.

Инструмент не предполагает необходимости проверять, справедливы ли отметки, его задача *задавать направление* самообучению, ожидается, что с самим собой пользователь будет честен. Однако, *явного запрета на проверку справедливости ответок при их установке тоже не накладывается*. Сейчас это попросту не выглядит реализуемым, но в определённых обучающих средах может быть вполне возможно.

Леса навыков образуют **федерацию**, каждый отдельный пользователь может использовать **несколько лесов** одновременно, возможно даже размещённых *на разных серверах* (отсюда "*федерация* серверов"), а также **одни леса могут ссылаться на другие**, в этих случаях клиенты вынуждены кроме интересующего леса загружать и все леса, от которых он зависит.

> Инструмент создаётся из предоложения, что обучающийся и составитель леса -- разные лица. Впрочем, особо продвинутые в самообучении люди, возожно, смогут составлять лес по мере продвижения по нему же. Стоит проверить, будет ли то работать на практике.

## Пример

### Ситуация

* Есть общедоступный веб-клиент, который любой желающий может открыть в браузере.
* Дима занимается поддержкой леса навыков по Ruby.
* Вася занимается поддержкой леса навыков по Rails.
  - Некоторые навыки в лесу по Rails требуют навыков Ruby, потому Вася ссылается на лес Димы по Ruby в некоторых местах

### Деятельность

* Паша загорелся мыслью изучить Rails.
* Паша наткнулся на "всю эту затею с лесами навыков" и решил их использовать, чтобы придать процессу изучения направление.
* Паша натыкается на ссылку, которая запускает веб-клиент для леса навыков по Rails.
* Пашин браузер загружает клиент, замечает в URL ссылку на лес навыков по Rails и загружает его
* *(Лениво/сразу?)* Пашин браузер, видя, что некоторые навыки Rails зависят от некоторых навыков Ruby, загружает Димин лес навыков по Ruby
* Точка входа: веб-клиент леса навыков запускается, поначалу показывая только узлы **без требований**
  - Скорее всего, это должен был узел с заголовком вида *"Хочу изучить X!"* для каждого леса (закрепить как хорошую практику? позволить несколько точек входа?)
  - Поскольку в клиент загружено 2 леса навыков и никакой из них не является *главным* (это вообще нужно?), точек точно должно быть несколько: одна по Ruby, одна по Rails, но ведь Паша помнит, зачем он за это взялся
* Паша ставит отметку на точке входа в Rails, с заголовком "Хочу изучить Rails!"
  - В этом узле содержатся ссылки на источники о том **что такое Rails**, и отмечая этот узел, Паша заявляет, что знает это
  - Интерфейс выводит возможные дальнейшие направления
* *(Главный цикл)* Паша выбирает узел и изучает указанные в нём материалы, пока не решает, что изучил всё, чего этот узел касается
* Позанимавшись (и поотмечав немного узлов!), Паша натыкается на навык Rails, требующий определённого навыка Ruby из ветки, которую он даже не начал; интерфейс выводит пути до всех навыков, которые ему потребуются, до узлов, которые Паша уже может отметить (в данном случае точка входа в Ruby)
* Полный решимости продолжать, он отмечает "Хочу изучить Ruby!", изучив материалы по теме
  - На практике это должно произойти если не сразу, то очень быстро: чтобы **запустить** Rails, надо сначала организовать на компьютере среду для работы с Ruby.
* Попрактиковавшись с Ruby, он доходит до уровня, достаточного для продолжения леса Rails, но проникается интересом к Ruby и решает продолжать изучение в сторону Ruby
* ???

> Пример, конечно, сильно упрощён. К примеру, не упомянута работа с командой строкой

## Цели

* Описать абстракции вокруг и внутри леса навыков
* Разработать неинтерактивные леса навыков (в качестве примера) для нескольких связанных технологий
* Разработать формат (возможно, не один?) для передачи лесов
  - Сначала автономных, потом со ссылками
* Обозначить процесс и хорошие практики, связанные с поддержкой леса
  - Графы со временем меняются авторами, клиентам надо либо запоминать версию, с которой они начали, либо адаптироваться к изменениям
    + Определить поведение в случае конфликтов между состоянием у пользователя и изменившейся структурой леса
    + Правила кэширования (начал использовать -- в кэш, обновлять только явно?)
    + Привязать состояние у пользователя к конкретной версии леса и дать реализациям решать, как обновляться?
    + Понять, нужны ли механизмы проверки наличия обновлений и можно ли сделать такой механизм необязательным
  - Разработать проверялку
    + Проверять общую структуру (схема? JSON schema?)
    + Проверять ацикличность
* Разработать интерфейс-прототип
  - ...первое время не парясь о том, что версий может быть много
* Мобильное приложение? (Шутка или не очень?)
* Передача состояния между клиентами? (Файлом? Внутри ссылки?)
* Определить, как использовать URL (относительные, абсолютные?)
* Подумать над особенностями работы в одной сессии с несколькими непересекающимися лесами сразу
* Политика расширений: как относимся к дополнительным полям? Как избежать конфликтов расширений?

## Философия

* **Не перегружать. Мотивировать учиться** показывая "это не **настолько** сложно".
  - Не надо вываливать кучу информации разом. Выводить новую информацию только когда пользователь готов её воспринимать.
  - ...но при этом не мешать. Если пользователь явно хочет увидеть "всю картину", это его выбор.
  - Продолжая аналогию с Rails, вам не нужно *досконально* знать Ruby, чтобы работать с Rails, а полноценная книга по Ruby может уже оглавлением подействовать угнетающе (а делать первый шаг порой бывает *сложнее всего*).
* **Оставлять выбор.** Если определённая точка открывает несколько вариантов дальнейших тем для изучения, выбор надо оставить пользователю.
  - Это существенное отличие от обучения "по книжке" в порядке, навязанном книгой, пользователь может продолжать учиться даже если в каком-то направлении он застрял. Он может просто на время заняться другим направлением, а к этому вернуться позже.
  - Книга "A Well-Grounded Rubyist" за авторством Дэвида Блэка освещает разные стороны Ruby в порядке "поиска в ширину"; в книге прямо так и написано; возможно, исполнение этой порции знаний в виде книги наложило определённые нежелательные ограничения (хотя может это и преувеличение)
* **Придерживайтесь выбранной темы.** Если для изучения одной технологии нужно изучить сколько-то тем по другой, надо стараться вынести эти темы в отдельный лес навыков.
  - Ссылка на чужой лес навыков может быть хорошей идеей, это может открыть новые темы для изучения даже составителю!
  - Лес по этой технологии может потребоваться и для других технологий. К примеру, навыки Ruby не надо вшивать **внутрь** леса по Rails, ведь... Ну, Chef использует Ruby. Calabash тоже. И другие проекты!

## Зачем

* Отслеживать собственное самообучение, очевидно
* Простой способ наглядно сообщить о своих навыках тем, кто ими интересуется: "детали там по запросу можно получить, и много!"

## Теория

Основная абстракция это **навык**. **Лес навыков** определяется, как ориентированный ациклический [граф][1], где отдельные узлы (вершины) представляют **навыки** а соединения (рёбра) представляют **требования**. Для каждого пользователя каждый узел может быть **отмечен** или **не отмечен**. Каждый **навык** может быть в одном из следующих состояний, определённых в терминах **наличия**/**отсутствия отметки** и окружающих узлов:

* Освоен -- "самый край", освоенный, но ещё не применённый в освоении других навык
  - **Имеет отметку**
  - Все навыки, для которых он требуется **отметок не имеют**
* Виден -- навык, все требования для которого освоены, его можно осваивать сейчас
  - **Не имеет отметки**
  - Все навыки, требуемые для него (возможно, таких нет, [согласно vacuous truth][2] условие выполняется всегда) **отмечены**
* Неизвестен -- навык, находящийся настолько далеко от освоенных, что о его существовании можно даже не догадываться
  - **Не имеет отметки**
  - Существует *хотя бы один* **не имеющий отметки** навык, требуемый для него
* Активен -- использовался для постижения других навыков, применялся на практике
  - **Имеет отметку**
  - Существует *хотя бы один* **имеющий отметку** навык, требующий его

> "Требуемость" это разновидность ребра графа. Нужны ли для навыков другие формы зависимости, как то "открытие", для которого отметка *любого* зависимого узла "открывает" (делает "видным") этот навык, непонятно; надо подобрать примеры использования.

---

#### Прдолжение следует...

## Ссылки

* [Изначальная концепция][3].

  [1]: https://ru.wikipedia.org/wiki/%D0%93%D1%80%D0%B0%D1%84_%28%D0%BC%D0%B0%D1%82%D0%B5%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0%29
  [2]: https://en.wikipedia.org/wiki/Vacuous_truth
  [3]: http://meta.ru.stackoverflow.com/a/2793/181100
